<!doctype html> <!-- (c) 2022, Alexander (Shúrko) Stadnichénko -->
<html lang=ru>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="res/css/index.css" type="text/css" />
	<title>FSML In His Grace</title>
</head>

<body>
	<div class="wrapper">
		<main class="longread m-tb-32px">

			<h1 class="main-header flex row justify-center fs-72 m-tb-64px">
				FSML In His Grace
			</h1>

			<p>
				FSML - это постфиксный конкатенативный гомоиконный язык программирования, призванный дать мне и всем
				желающим
				привычную, комфортную постфиксную среду программирования и быть конкурентоспособным в современных
				реалиях,
				эффективным во всех отношениях.
			</p>

			<p>
				Разработка находится в зачаточном состоянии, поэтому большая часть документа будет посвящена
				концепции языка
				и планам его развития, а не тому, что уже сделано. Хотя для затравки я сначала покажу несколько
				небольших
				примеров того, что уже сделано. Затем опишу концепцию. И в конце приведу технические подробности.
				Надеюсь, что читатель в общих чертах знаком с постфиксными языками прогаммирования, как Форт, Фактор
				или 8th.
			</p>

			<p>
				В первую очередь заметьте, что объекты, дублируемые с помощью классических Форт-слов как dup, over, и
				т.д. доступны по ссылке, а не по значению. В частности это означает следующее.
			</p>

			<div class="source-code">
				<p>
					1 dup
				</p>
				<p>
					[2] 1 -> 1
				</p>
				<p>
					25 +
				</p>
				<p>
					[2] 1 + 25 -> 1 + 25
				</p>
			</div>

			<p>
				Упс! Это не то, чего бы вы ожидали от Форта или Фактора. В этих языках результат был бы таким:
			</p>

			<div class="source-code">
				<p>
					1 dup
				</p>
				<p>
					stack: 1 -> 1
				</p>
				<p>
					25 +
				</p>
				<p>
					stack: 26 -> 1
				</p>
			</div>

			<p>
				Это объясняется тем, что в FSML продублировав элемент стека используя DUP мы на самом деле
				продублировали ссылку на объект, так как абстрактный стек в действительности может содержать
				только ссылки. Таким образом оба получившихся элемента стека - это ссылки на один объект.
				И прибавив к нему 25, мы сделали этот объект выражением 25&nbsp;+&nbsp;1. Поэтому два верхних
				элемента стека ссылаются на это выражение.
			</p>

			<p>
				Нужен "ind" после "dup", чтобы разделить их. "ind" означает независимый или индивидуальный,
				на ваш выбор. Он создаёт новый объект и переставляет ссылку на него. Этот новый объект всё ещё
				ссылается на то же подвыражение, что и раньше. Но все последующие операции над ним будут создавать
				другой семантический граф. С этого момента они будут иметь разную историю операций над ними,
				запечатлённую в вершинах абстрактных семантических графов (asg). Но то, что было сделано до "ind"
				останется общей частью истории операций над элементом.
			</p>

			<div class="source-code">
				<p>
					1 dup ind
				</p>
				<p>
					[2] 1 -> 1
				</p>
				<p>
					25 +
				</p>
				<p>
					[2] 1 + 25 -> 1
				</p>
			</div>

			<p>
				Существует также операция "dc", что означает deep copy. dc производит глубокое копирование asg,
				соответствующего элементу стека. С этого момента появляется полностью новый граф, который не имеет общих
				вершин с исходным. Новый граф не является точной копией исходного. Например вершины графа могут
				содержать uid, которые по определению не могут быть такими же, как в прототипе.
			</p>


			<p>
				1. Вычисляем факториал числа&nbsp;12 с if и while&nbsp;:
			</p>

			<div class="source-code">
				<p>
					12 dup [ 1 [ over * over 1 - ] while swap dp ] [ 0 ] if .eval
				</p>
				<p>
					\ [479001600]
				</p>
			</div>

			<p>
				2. Считываем и записываем переменную в старом добром трогательном Форт-стиле с @ и&nbsp;!&nbsp;:
			</p>

			<div class="source-code">
				<p>
					123 some_name !
					<br> some_name @ 456 +
					<br> .eval dp
				</p>
				<p>
					\ [ 579 ]
				</p>
			</div>

			<p>
				3. Строки&nbsp;:
			</p>

			<div class="source-code">
				<p>
					'Кладём на стек строку с пробелами и сразу же её сбрасываем при помощи dp' dp
				<div></div>
				<br> 'dp - это короткий псевдоним для классического drop' dp
				<div></div>
				<br> 'Без отступа между левой кавычкой и началом строки, здесь это не нужно' dp
				<br> "Или с двойными кавычками" dp
				<div></div>
				<br> Или_вообще_без_кавычек_если_строка_не_содержит_пробелов dp
				<div></div>
				<br> '\ Полноценные комментарии ещё не реализованы, поэтому пока это и для комментариев, хотя начать
				строку можно с обратного слэша Форт-комментария, чтобы было понятно, но всё же это только строка' dp
				</p>
			</div>

			<p>
				4. Склеиваем сторки в цикле&nbsp;:
			</p>

			<div class="source-code">
				<p>
					"" comma !
					<br> 2 "" [ comma @ + ' somename_' + over + '_alias = somename_'
					<br> + over + ', ' comma ! over 1 - ] while swap dp
					<br> 'let ' swap + ';' +
					<br> .eval dp
				</p>
				<p>
					\ [let somename_2_alias = somename_2, somename_1_alias = somename_1;]
				</p>
			</div>

			<p>
				5. Создаём пустой массив и кладём пару элементов&nbsp;:
			</p>

			<div class="source-code">
				<p>
					list 12 push 34 push
					<br> .js
				</p>
				<p>
					\ var subex_2 = [];
					<br> \ var subex_1 = (subex_2 .push (12), subex_2);
					<br> \ var subex_0 = (subex_1 .push (34), subex_1);
				</p>
			</div>

			<p>
			</p>

			<p class="flex row justify-center mt-64px mb-32px">
				© 2022, 2023 Александр (Шýрко) Стадничéнко
			</p>
		</main>
	</div>
</body>

</html>